var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/type-detect/type-detect.js
var require_type_detect = __commonJS({
  "node_modules/type-detect/type-detect.js"(exports, module2) {
    (function(global2, factory) {
      typeof exports === "object" && typeof module2 !== "undefined" ? module2.exports = factory() : typeof define === "function" && define.amd ? define(factory) : global2.typeDetect = factory();
    })(exports, function() {
      "use strict";
      var promiseExists = typeof Promise === "function";
      var globalObject2 = typeof self === "object" ? self : global;
      var symbolExists = typeof Symbol !== "undefined";
      var mapExists = typeof Map !== "undefined";
      var setExists = typeof Set !== "undefined";
      var weakMapExists = typeof WeakMap !== "undefined";
      var weakSetExists = typeof WeakSet !== "undefined";
      var dataViewExists = typeof DataView !== "undefined";
      var symbolIteratorExists = symbolExists && typeof Symbol.iterator !== "undefined";
      var symbolToStringTagExists = symbolExists && typeof Symbol.toStringTag !== "undefined";
      var setEntriesExists = setExists && typeof Set.prototype.entries === "function";
      var mapEntriesExists = mapExists && typeof Map.prototype.entries === "function";
      var setIteratorPrototype = setEntriesExists && Object.getPrototypeOf((/* @__PURE__ */ new Set()).entries());
      var mapIteratorPrototype = mapEntriesExists && Object.getPrototypeOf((/* @__PURE__ */ new Map()).entries());
      var arrayIteratorExists = symbolIteratorExists && typeof Array.prototype[Symbol.iterator] === "function";
      var arrayIteratorPrototype = arrayIteratorExists && Object.getPrototypeOf([][Symbol.iterator]());
      var stringIteratorExists = symbolIteratorExists && typeof String.prototype[Symbol.iterator] === "function";
      var stringIteratorPrototype = stringIteratorExists && Object.getPrototypeOf(""[Symbol.iterator]());
      var toStringLeftSliceLength = 8;
      var toStringRightSliceLength = -1;
      function typeDetect(obj) {
        var typeofObj = typeof obj;
        if (typeofObj !== "object") {
          return typeofObj;
        }
        if (obj === null) {
          return "null";
        }
        if (obj === globalObject2) {
          return "global";
        }
        if (Array.isArray(obj) && (symbolToStringTagExists === false || !(Symbol.toStringTag in obj))) {
          return "Array";
        }
        if (typeof window === "object" && window !== null) {
          if (typeof window.location === "object" && obj === window.location) {
            return "Location";
          }
          if (typeof window.document === "object" && obj === window.document) {
            return "Document";
          }
          if (typeof window.navigator === "object") {
            if (typeof window.navigator.mimeTypes === "object" && obj === window.navigator.mimeTypes) {
              return "MimeTypeArray";
            }
            if (typeof window.navigator.plugins === "object" && obj === window.navigator.plugins) {
              return "PluginArray";
            }
          }
          if ((typeof window.HTMLElement === "function" || typeof window.HTMLElement === "object") && obj instanceof window.HTMLElement) {
            if (obj.tagName === "BLOCKQUOTE") {
              return "HTMLQuoteElement";
            }
            if (obj.tagName === "TD") {
              return "HTMLTableDataCellElement";
            }
            if (obj.tagName === "TH") {
              return "HTMLTableHeaderCellElement";
            }
          }
        }
        var stringTag = symbolToStringTagExists && obj[Symbol.toStringTag];
        if (typeof stringTag === "string") {
          return stringTag;
        }
        var objPrototype = Object.getPrototypeOf(obj);
        if (objPrototype === RegExp.prototype) {
          return "RegExp";
        }
        if (objPrototype === Date.prototype) {
          return "Date";
        }
        if (promiseExists && objPrototype === Promise.prototype) {
          return "Promise";
        }
        if (setExists && objPrototype === Set.prototype) {
          return "Set";
        }
        if (mapExists && objPrototype === Map.prototype) {
          return "Map";
        }
        if (weakSetExists && objPrototype === WeakSet.prototype) {
          return "WeakSet";
        }
        if (weakMapExists && objPrototype === WeakMap.prototype) {
          return "WeakMap";
        }
        if (dataViewExists && objPrototype === DataView.prototype) {
          return "DataView";
        }
        if (mapExists && objPrototype === mapIteratorPrototype) {
          return "Map Iterator";
        }
        if (setExists && objPrototype === setIteratorPrototype) {
          return "Set Iterator";
        }
        if (arrayIteratorExists && objPrototype === arrayIteratorPrototype) {
          return "Array Iterator";
        }
        if (stringIteratorExists && objPrototype === stringIteratorPrototype) {
          return "String Iterator";
        }
        if (objPrototype === null) {
          return "Object";
        }
        return Object.prototype.toString.call(obj).slice(toStringLeftSliceLength, toStringRightSliceLength);
      }
      return typeDetect;
    });
  }
});

// lib/index.mjs
var lib_exports = {};
__export(lib_exports, {
  default: () => lib_default
});
module.exports = __toCommonJS(lib_exports);

// lib/global.mjs
var globalObject;
if (typeof global !== "undefined") {
  globalObject = global;
} else if (typeof window !== "undefined") {
  globalObject = window;
} else {
  globalObject = self;
}
var global_default = globalObject;

// lib/throws-on-proto.mjs
var throwsOnProto;
try {
  const object = {};
  object.__proto__;
  throwsOnProto = false;
} catch (_) {
  throwsOnProto = true;
}
var throws_on_proto_default = throwsOnProto;

// lib/copy-prototype-methods.mjs
var disallowedProperties = [
  // ignore size because it throws from Map
  "size",
  "caller",
  "callee",
  "arguments"
];
if (throws_on_proto_default) {
  disallowedProperties.push("__proto__");
}
function copyPrototypeMethods(prototype) {
  const call = Function.call;
  return Object.getOwnPropertyNames(prototype).reduce(
    function(result, name) {
      if (disallowedProperties.includes(name)) {
        return result;
      }
      if (typeof prototype[name] !== "function") {
        return result;
      }
      result[name] = call.bind(prototype[name]);
      return result;
    },
    /* @__PURE__ */ Object.create(null)
  );
}
var copy_prototype_methods_default = copyPrototypeMethods;

// lib/prototypes.mjs
var prototypes_default = {
  array: copy_prototype_methods_default(Array.prototype),
  function: copy_prototype_methods_default(Function.prototype),
  map: copy_prototype_methods_default(Map.prototype),
  object: copy_prototype_methods_default(Object.prototype),
  set: copy_prototype_methods_default(Set.prototype),
  string: copy_prototype_methods_default(String.prototype)
};

// lib/called-in-order.mjs
var every = prototypes_default.array.every;
function hasCallsLeft(callMap, spy) {
  if (callMap[spy.id] === void 0) {
    callMap[spy.id] = 0;
  }
  return callMap[spy.id] < spy.callCount;
}
function checkAdjacentCalls(callMap, spy, index, spies) {
  var calledBeforeNext = true;
  if (index !== spies.length - 1) {
    calledBeforeNext = spy.calledBefore(spies[index + 1]);
  }
  if (hasCallsLeft(callMap, spy) && calledBeforeNext) {
    callMap[spy.id] += 1;
    return true;
  }
  return false;
}
function calledInOrder(spies) {
  var callMap = {};
  var _spies = arguments.length > 1 ? arguments : spies;
  return every(_spies, checkAdjacentCalls.bind(null, callMap));
}
var called_in_order_default = calledInOrder;

// lib/class-name.mjs
function className(value) {
  const name = value.constructor && value.constructor.name;
  return name || null;
}
var class_name_default = className;

// lib/deprecated.js
var deprecated_exports = {};
__export(deprecated_exports, {
  default: () => deprecated_default,
  defaultMsg: () => defaultMsg,
  printWarning: () => printWarning,
  wrap: () => wrap
});
function wrap(func, msg) {
  var wrapped = function() {
    printWarning(msg);
    return func.apply(this, arguments);
  };
  if (func.prototype) {
    wrapped.prototype = func.prototype;
  }
  return wrapped;
}
function defaultMsg(packageName, funcName) {
  return `${packageName}.${funcName} is deprecated and will be removed from the public API in a future version of ${packageName}.`;
}
function printWarning(msg) {
  if (typeof process === "object" && process.emitWarning) {
    process.emitWarning(msg);
  } else if (console.info) {
    console.info(msg);
  } else {
    console.log(msg);
  }
}
var deprecated_default = {
  defaultMsg,
  printWarning,
  wrap
};

// lib/every.mjs
function every2(obj, fn) {
  var pass = true;
  try {
    obj.forEach(function() {
      if (!fn.apply(this, arguments)) {
        throw new Error();
      }
    });
  } catch (e) {
    pass = false;
  }
  return pass;
}
var every_default = every2;

// lib/function-name.mjs
function functionName(func) {
  if (!func) {
    return "";
  }
  try {
    return func.displayName || func.name || // Use function decomposition as a last resort to get function
    // name. Does not rely on function decomposition to work - if it
    // doesn't debugging will be slightly less informative
    // (i.e. toString will say 'spy' rather than 'myFunc').
    (String(func).match(/function ([^\s(]+)/) || [])[1];
  } catch (e) {
    return "";
  }
}
var function_name_default = functionName;

// lib/order-by-first-call.mjs
var { slice, sort } = prototypes_default.array;
function comparator(a, b) {
  var aCall = a.getCall(0);
  var bCall = b.getCall(0);
  var aId = aCall && aCall.callId || -1;
  var bId = bCall && bCall.callId || -1;
  return aId < bId ? -1 : 1;
}
function orderByFirstCall(spies) {
  return sort(slice(spies), comparator);
}
var order_by_first_call_default = orderByFirstCall;

// lib/type-of.mjs
var import_type_detect = __toESM(require_type_detect(), 1);
function typeOf(value) {
  return (0, import_type_detect.default)(value).toLowerCase();
}
var type_of_default = typeOf;

// lib/value-to-string.mjs
function valueToString(value) {
  if (value && value.toString) {
    return value.toString();
  }
  return String(value);
}
var value_to_string_default = valueToString;

// lib/index.mjs
var lib_default = {
  global: global_default,
  calledInOrder: called_in_order_default,
  className: class_name_default,
  deprecated: deprecated_exports,
  every: every_default,
  functionName: function_name_default,
  orderByFirstCall: order_by_first_call_default,
  prototypes: prototypes_default,
  typeOf: type_of_default,
  valueToString: value_to_string_default
};
